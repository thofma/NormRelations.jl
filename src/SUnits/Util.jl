
# Return the abelian group Z^n/M where M is the matrix whose rows generate the 
# lattice of relations of primes in S.
function abelian_group(f::MapSUnitGrpFacElem)
  M = relation_matrix(f)
  return abelian_group(M)
end

# Given the class group CK (abelian group) together with the generating set S that
# we used to create it, and a subset S0 of ideals, return the elements of S0
# as elements of CK
function _as_elements_of_class_group(
    S::Vector{NfOrdIdl},
    CK::GrpAbFinGen,
    cache::NormRelCache; 
    parisizemax=PARISIZEMAX,
    stable=STABLE,
    strategy=:classic)
  
  @assert order(S[1]) == order(cache)

  SinCK = elem_type(CK)[]
  SK = idealset(cache)
  if issubset(S, SK)
    # CK is an abelian group and the generators correspond to the elements of S
    # So, S[i] -> gen(CK, i)
    for p in S
      i = findfirst(isequal(p), SK)
      @assert i !== nothing
      push!(SinCK, gen(CK, i))
    end
  else
    # TODO: decompose or compute new S-unit group?
    for p in S
      @vtime :SUnits 2 _, v = decompose(p, cache, parisizemax=parisizemax, 
				      stable=stable, strategy=strategy)
      push!(SinCK, CK(v))
    end
  end
  return SinCK
end

# return the subgroup of the class group of K generated by the primes in S
function class_group_subgroup(
    S::Vector{NfOrdIdl},
    cache::NormRelCache; 
    parisizemax=PARISIZEMAX,
    stable=STABLE,
    strategy=:classic)

  D = _as_elements_of_class_group(S, cache, parisizemax=parisizemax, stable=stable, 
				  strategy=strategy)
  CK = parent(D[1])
  return sub(CK, D)
end

function sunit_group_subgroup(
    S::Vector{NfOrdIdl},
    SU::GrpAbFinGen,
    mSU::MapSUnitGrpFacElem)

  S0 = mSU.idl
  @assert issubset(S, S0)

  K = nf(S[1])
  r1, r2 = signature(K)
  
  gens = [SU[i] for i=1:r1+r2]
  for P in S
    i = findfirst(isequal(P), S0)
    push!(gens, SU[i])
  end

  new_SU, m = sub(SU, gens)
  return new_SU, m*mSU
end

# Remove all conjugates of the prime ideal P from S0 and return them.
function remove_conjugates!(S0::Vector{NfOrdIdl}, P::NfOrdIdl)
  primes = [minimum(Q) for Q in S0]
  indices = findall(isequal(minimum(P)), primes)
  conj = [S0[i] for i in indices]
  deleteat!(S0, indices)
  return conj
end
